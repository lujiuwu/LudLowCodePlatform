{"version":3,"file":"js/chunk-element-plus-2c23bcb8.947a4e03.js","mappings":"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","sources":["webpack://lud/../../../packages/utils/dom/aria.ts","webpack://lud/../../../packages/utils/error.ts","webpack://lud/../../../packages/utils/vue/refs.ts","webpack://lud/../../../packages/utils/vue/props/runtime.ts","webpack://lud/../../../packages/utils/dom/event.ts","webpack://lud/../../../packages/utils/vue/icon.ts","webpack://lud/../../../packages/utils/dom/style.ts","webpack://lud/../../../packages/utils/raf.ts","webpack://lud/../../../packages/utils/vue/install.ts","webpack://lud/../../../packages/utils/objects.ts","webpack://lud/../../../packages/utils/browser.ts","webpack://lud/../../../packages/utils/typescript.ts","webpack://lud/../../../packages/utils/vue/validator.ts","webpack://lud/../../../packages/utils/vue/vnode.ts","webpack://lud/../../../packages/utils/dom/position.ts","webpack://lud/../../../packages/utils/dom/scroll.ts","webpack://lud/../../../packages/utils/strings.ts","webpack://lud/../../../packages/utils/i18n.ts","webpack://lud/../../../packages/utils/arrays.ts","webpack://lud/../../../packages/utils/types.ts"],"sourcesContent":["const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex=\"-1\"]),input:not([disabled]),input:not([type=\"hidden\"]),select:not([disabled]),textarea:not([disabled])`\n\nconst isHTMLElement = (e: unknown): e is Element => {\n  if (typeof Element === 'undefined') return false\n  return e instanceof Element\n}\n\n/**\n * Determine if the testing element is visible on screen no matter if its on the viewport or not\n */\nexport const isVisible = (element: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return true\n  const computed = getComputedStyle(element)\n  // element.offsetParent won't work on fix positioned\n  // WARNING: potential issue here, going to need some expert advices on this issue\n  return computed.position === 'fixed' ? false : element.offsetParent !== null\n}\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  return Array.from(\n    element.querySelectorAll<HTMLElement>(FOCUSABLE_ELEMENT_SELECTORS)\n  ).filter((item: HTMLElement) => isFocusable(item) && isVisible(item))\n}\n\n/**\n * @desc Determine if target element is focusable\n * @param element {HTMLElement}\n * @returns {Boolean} true if it is focusable\n */\nexport const isFocusable = (element: HTMLElement): boolean => {\n  if (\n    element.tabIndex > 0 ||\n    (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)\n  ) {\n    return true\n  }\n  if (\n    element.tabIndex < 0 ||\n    element.hasAttribute('disabled') ||\n    element.getAttribute('aria-disabled') === 'true'\n  ) {\n    return false\n  }\n\n  switch (element.nodeName) {\n    case 'A': {\n      // casting current element to Specific HTMLElement in order to be more type precise\n      return (\n        !!(element as HTMLAnchorElement).href &&\n        (element as HTMLAnchorElement).rel !== 'ignore'\n      )\n    }\n    case 'INPUT': {\n      return !(\n        (element as HTMLInputElement).type === 'hidden' ||\n        (element as HTMLInputElement).type === 'file'\n      )\n    }\n    case 'BUTTON':\n    case 'SELECT':\n    case 'TEXTAREA': {\n      return true\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * Trigger an event\n * mouseenter, mouseleave, mouseover, keyup, change, click, etc.\n * @param  {HTMLElement} elm\n * @param  {String} name\n * @param  {*} opts\n */\nexport const triggerEvent = function (\n  elm: HTMLElement,\n  name: string,\n  ...opts: Array<boolean>\n): HTMLElement {\n  let eventName: string\n\n  if (name.includes('mouse') || name.includes('click')) {\n    eventName = 'MouseEvents'\n  } else if (name.includes('key')) {\n    eventName = 'KeyboardEvent'\n  } else {\n    eventName = 'HTMLEvents'\n  }\n  const evt = document.createEvent(eventName)\n\n  evt.initEvent(name, ...opts)\n  elm.dispatchEvent(evt)\n  return elm\n}\n\nexport const isLeaf = (el: HTMLElement) => !el.getAttribute('aria-owns')\n\nexport const getSibling = (\n  el: HTMLElement,\n  distance: number,\n  elClass: string\n) => {\n  const { parentNode } = el\n  if (!parentNode) return null\n  const siblings = parentNode.querySelectorAll(elClass)\n  const index = Array.prototype.indexOf.call(siblings, el)\n  return siblings[index + distance] || null\n}\n\nexport const focusElement = (\n  el?: HTMLElement | { focus: () => void } | null,\n  options?: FocusOptions\n) => {\n  if (!el || !el.focus) return\n  let cleanup: boolean = false\n\n  if (isHTMLElement(el) && !isFocusable(el) && !el.getAttribute('tabindex')) {\n    el.setAttribute('tabindex', '-1')\n    cleanup = true\n  }\n\n  el.focus(options)\n\n  if (isHTMLElement(el) && cleanup) {\n    el.removeAttribute('tabindex')\n  }\n}\n\nexport const focusNode = (el: HTMLElement) => {\n  if (!el) return\n  focusElement(el)\n  !isLeaf(el) && el.click()\n}\n","import { isString } from './types'\n\nclass ElementPlusError extends Error {\n  constructor(m: string) {\n    super(m)\n    this.name = 'ElementPlusError'\n  }\n}\n\nexport function throwError(scope: string, m: string): never {\n  throw new ElementPlusError(`[${scope}] ${m}`)\n}\n\nexport function debugWarn(err: Error): void\nexport function debugWarn(scope: string, message: string): void\nexport function debugWarn(scope: string | Error, message?: string): void {\n  if (process.env.NODE_ENV !== 'production') {\n    const error: Error = isString(scope)\n      ? new ElementPlusError(`[${scope}] ${message}`)\n      : scope\n    // eslint-disable-next-line no-console\n    console.warn(error)\n  }\n}\n","import { isFunction } from '../types'\n\nimport type { ComponentPublicInstance, Ref } from 'vue'\n\nexport type RefSetter = (\n  el: Element | ComponentPublicInstance | undefined\n) => void\n\nexport const composeRefs = (\n  ...refs: (Ref<HTMLElement | undefined> | RefSetter)[]\n) => {\n  return (el: Element | ComponentPublicInstance | null) => {\n    refs.forEach((ref) => {\n      if (isFunction(ref)) {\n        ref(el as Element | ComponentPublicInstance)\n      } else {\n        ref.value = el as HTMLElement | undefined\n      }\n    })\n  }\n}\n","import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../../types'\nimport { hasOwn } from '../../objects'\n\nimport type { PropType } from 'vue'\nimport type {\n  EpProp,\n  EpPropConvert,\n  EpPropFinalized,\n  EpPropInput,\n  EpPropMergeType,\n  IfEpProp,\n  IfNativePropType,\n  NativePropType,\n} from './types'\n\nexport const epPropKey = '__epPropKey'\n\nexport const definePropType = <T>(val: any): PropType<T> => val\n\nexport const isEpProp = (val: unknown): val is EpProp<any, any, any> =>\n  isObject(val) && !!(val as any)[epPropKey]\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport const buildProp = <\n  Type = never,\n  Value = never,\n  Validator = never,\n  Default extends EpPropMergeType<Type, Value, Validator> = never,\n  Required extends boolean = false\n>(\n  prop: EpPropInput<Type, Value, Validator, Default, Required>,\n  key?: string\n): EpPropFinalized<Type, Value, Validator, Default, Required> => {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(prop) || isEpProp(prop)) return prop as any\n\n  const { values, required, default: defaultValue, type, validator } = prop\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(prop, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const epProp: any = {\n    type,\n    required: !!required,\n    validator: _validator,\n    [epPropKey]: true,\n  }\n  if (hasOwn(prop, 'default')) epProp.default = defaultValue\n  return epProp\n}\n\nexport const buildProps = <\n  Props extends Record<\n    string,\n    | { [epPropKey]: true }\n    | NativePropType\n    | EpPropInput<any, any, any, any, any>\n  >\n>(\n  props: Props\n): {\n  [K in keyof Props]: IfEpProp<\n    Props[K],\n    Props[K],\n    IfNativePropType<Props[K], Props[K], EpPropConvert<Props[K]>>\n  >\n} =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as any\n","export const composeEventHandlers = <E>(\n  theirsHandler?: (event: E) => boolean | void,\n  oursHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) => {\n  const handleEvent = (event: E) => {\n    const shouldPrevent = theirsHandler?.(event)\n\n    if (checkForDefaultPrevented === false || !shouldPrevent) {\n      return oursHandler?.(event)\n    }\n  }\n  return handleEvent\n}\n\ntype WhenMouseHandler = (e: PointerEvent) => any\nexport const whenMouse = (handler: WhenMouseHandler): WhenMouseHandler => {\n  return (e: PointerEvent) =>\n    e.pointerType === 'mouse' ? handler(e) : undefined\n}\n","import {\n  CircleCheck,\n  CircleClose,\n  CircleCloseFilled,\n  Close,\n  InfoFilled,\n  Loading,\n  SuccessFilled,\n  WarningFilled,\n} from '@element-plus/icons-vue'\nimport { definePropType } from './props'\n\nimport type { Component } from 'vue'\n\nexport const iconPropType = definePropType<string | Component>([\n  String,\n  Object,\n  Function,\n])\n\nexport const CloseComponents = {\n  Close,\n}\n\nexport const TypeComponents = {\n  Close,\n  SuccessFilled,\n  InfoFilled,\n  WarningFilled,\n  CircleCloseFilled,\n}\n\nexport const TypeComponentsMap = {\n  primary: InfoFilled,\n  success: SuccessFilled,\n  warning: WarningFilled,\n  error: CircleCloseFilled,\n  info: InfoFilled,\n}\n\nexport const ValidateComponentsMap = {\n  validating: Loading,\n  success: CircleCheck,\n  error: CircleClose,\n}\n","import { isNumber, isObject, isString, isStringNumber } from '../types'\nimport { isClient } from '../browser'\nimport { camelize } from '../strings'\nimport { entriesOf, keysOf } from '../objects'\nimport { debugWarn } from '../error'\n\nimport type { CSSProperties } from 'vue'\n\nconst SCOPE = 'utils/dom/style'\n\nexport const classNameToArray = (cls = '') =>\n  cls.split(' ').filter((item) => !!item.trim())\n\nexport const hasClass = (el: Element, cls: string): boolean => {\n  if (!el || !cls) return false\n  if (cls.includes(' ')) throw new Error('className should not contain space.')\n  return el.classList.contains(cls)\n}\n\nexport const addClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.add(...classNameToArray(cls))\n}\n\nexport const removeClass = (el: Element, cls: string) => {\n  if (!el || !cls.trim()) return\n  el.classList.remove(...classNameToArray(cls))\n}\n\nexport const getStyle = (\n  element: HTMLElement,\n  styleName: keyof CSSProperties\n): string => {\n  if (!isClient || !element || !styleName) return ''\n\n  let key = camelize(styleName)\n  if (key === 'float') key = 'cssFloat'\n  try {\n    const style = (element.style as any)[key]\n    if (style) return style\n    const computed: any = document.defaultView?.getComputedStyle(element, '')\n    return computed ? computed[key] : ''\n  } catch {\n    return (element.style as any)[key]\n  }\n}\n\nexport const setStyle = (\n  element: HTMLElement,\n  styleName: CSSProperties | keyof CSSProperties,\n  value?: string | number\n) => {\n  if (!element || !styleName) return\n\n  if (isObject(styleName)) {\n    entriesOf(styleName).forEach(([prop, value]) =>\n      setStyle(element, prop, value)\n    )\n  } else {\n    const key: any = camelize(styleName)\n    element.style[key] = value as any\n  }\n}\n\nexport const removeStyle = (\n  element: HTMLElement,\n  style: CSSProperties | keyof CSSProperties\n) => {\n  if (!element || !style) return\n\n  if (isObject(style)) {\n    keysOf(style).forEach((prop) => removeStyle(element, prop))\n  } else {\n    setStyle(element, style, '')\n  }\n}\n\nexport function addUnit(value?: string | number, defaultUnit = 'px') {\n  if (!value) return ''\n  if (isNumber(value) || isStringNumber(value)) {\n    return `${value}${defaultUnit}`\n  } else if (isString(value)) {\n    return value\n  }\n  debugWarn(SCOPE, 'binding value must be a string or number')\n}\n","import { isClient } from './browser'\n\nexport const rAF = (fn: () => void) =>\n  isClient\n    ? window.requestAnimationFrame(fn)\n    : (setTimeout(fn, 16) as unknown as number)\n\nexport const cAF = (handle: number) =>\n  isClient ? window.cancelAnimationFrame(handle) : clearTimeout(handle)\n","import { NOOP } from '../functions'\n\nimport type { App, Directive } from 'vue'\nimport type { SFCInstallWithContext, SFCWithInstall } from './typescript'\n\nexport const withInstall = <T, E extends Record<string, any>>(\n  main: T,\n  extra?: E\n) => {\n  ;(main as SFCWithInstall<T>).install = (app): void => {\n    for (const comp of [main, ...Object.values(extra ?? {})]) {\n      app.component(comp.name, comp)\n    }\n  }\n\n  if (extra) {\n    for (const [key, comp] of Object.entries(extra)) {\n      ;(main as any)[key] = comp\n    }\n  }\n  return main as SFCWithInstall<T> & E\n}\n\nexport const withInstallFunction = <T>(fn: T, name: string) => {\n  ;(fn as SFCWithInstall<T>).install = (app: App) => {\n    ;(fn as SFCInstallWithContext<T>)._context = app._context\n    app.config.globalProperties[name] = fn\n  }\n\n  return fn as SFCInstallWithContext<T>\n}\n\nexport const withInstallDirective = <T extends Directive>(\n  directive: T,\n  name: string\n) => {\n  ;(directive as SFCWithInstall<T>).install = (app: App): void => {\n    app.directive(name, directive)\n  }\n\n  return directive as SFCWithInstall<T>\n}\n\nexport const withNoopInstall = <T>(component: T) => {\n  ;(component as SFCWithInstall<T>).install = NOOP\n\n  return component as SFCWithInstall<T>\n}\n","import { get, set } from 'lodash-unified'\n\nimport type { Entries } from 'type-fest'\nimport type { Arrayable } from '.'\n\nexport const keysOf = <T extends object>(arr: T) =>\n  Object.keys(arr) as Array<keyof T>\nexport const entriesOf = <T extends object>(arr: T) =>\n  Object.entries(arr) as Entries<T>\nexport { hasOwn } from '@vue/shared'\n\nexport const getProp = <T = any>(\n  obj: Record<string, any>,\n  path: Arrayable<string>,\n  defaultValue?: any\n): { value: T } => {\n  return {\n    get value() {\n      return get(obj, path, defaultValue)\n    },\n    set value(val: any) {\n      set(obj, path, val)\n    },\n  }\n}\n","import { isClient, isIOS } from '@vueuse/core'\n\nexport const isFirefox = (): boolean =>\n  isClient && /firefox/i.test(window.navigator.userAgent)\n\nexport { isClient, isIOS }\n","export const mutable = <T extends readonly any[] | Record<string, unknown>>(\n  val: T\n) => val as Mutable<typeof val>\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] }\n\nexport type HTMLElementCustomized<T> = HTMLElement & T\n\n/**\n * @deprecated stop to use null\n * @see {@link https://github.com/sindresorhus/meta/discussions/7}\n */\nexport type Nullable<T> = T | null\n\nexport type Arrayable<T> = T | T[]\nexport type Awaitable<T> = Promise<T> | T\n\ntype Primitive = null | undefined | string | number | boolean | symbol | bigint\ntype BrowserNativeObject = Date | FileList | File | Blob | RegExp\n\n/**\n * Check whether it is tuple\n *\n * 检查是否为元组\n *\n * @example\n * IsTuple<[1, 2, 3]> => true\n * IsTuple<Array[number]> => false\n */\ntype IsTuple<T extends ReadonlyArray<any>> = number extends T['length']\n  ? false\n  : true\n\n/**\n * Array method key\n *\n * 数组方法键\n */\ntype ArrayMethodKey = keyof any[]\n\n/**\n * Tuple index key\n *\n * 元组下标键\n *\n * @example\n * TupleKey<[1, 2, 3]> => '0' | '1' | '2'\n */\ntype TupleKey<T extends ReadonlyArray<any>> = Exclude<keyof T, ArrayMethodKey>\n\n/**\n * Array index key\n *\n * 数组下标键\n */\ntype ArrayKey = number\n\n/**\n * Helper type for recursively constructing paths through a type\n *\n * 用于通过一个类型递归构建路径的辅助类型\n */\ntype PathImpl<K extends string | number, V> = V extends\n  | Primitive\n  | BrowserNativeObject\n  ? `${K}`\n  : `${K}` | `${K}.${Path<V>}`\n\n/**\n * Type which collects all paths through a type\n *\n * 通过一个类型收集所有路径的类型\n *\n * @see {@link FieldPath}\n */\ntype Path<T> = T extends ReadonlyArray<infer V>\n  ? IsTuple<T> extends true\n    ? {\n        [K in TupleKey<T>]-?: PathImpl<Exclude<K, symbol>, T[K]>\n      }[TupleKey<T>] // tuple\n    : PathImpl<ArrayKey, V> // array\n  : {\n      [K in keyof T]-?: PathImpl<Exclude<K, symbol>, T[K]>\n    }[keyof T] // object\n\n/**\n * Type which collects all paths through a type\n *\n * 通过一个类型收集所有路径的类型\n *\n * @example\n * FieldPath<{ 1: number; a: number; b: string; c: { d: number; e: string }; f: [{ value: string }]; g: { value: string }[]; h: Date; i: FileList; j: File; k: Blob; l: RegExp }> => '1' | 'a' | 'b' | 'c' | 'f' | 'g' | 'c.d' | 'c.e' | 'f.0' | 'f.0.value' | 'g.number' | 'g.number.value' | 'h' | 'i' | 'j' | 'k' | 'l'\n */\nexport type FieldPath<T> = T extends object ? Path<T> : never\n","import { componentSizes, datePickTypes } from '@element-plus/constants'\n\nimport type { ComponentSize, DatePickType } from '@element-plus/constants'\n\nexport const isValidComponentSize = (val: string): val is ComponentSize | '' =>\n  ['', ...componentSizes].includes(val)\n\nexport const isValidDatePickType = (val: string): val is DatePickType =>\n  ([...datePickTypes] as string[]).includes(val)\n","import {\n  Comment,\n  Fragment,\n  Text,\n  createBlock,\n  createCommentVNode,\n  isVNode,\n  openBlock,\n} from 'vue'\nimport { camelize } from '../strings'\nimport { isArray } from '../types'\nimport { hasOwn } from '../objects'\nimport { debugWarn } from '../error'\n\nimport type {\n  VNode,\n  VNodeArrayChildren,\n  VNodeChild,\n  VNodeNormalizedChildren,\n} from 'vue'\n\nconst SCOPE = 'utils/vue/vnode'\n\nexport enum PatchFlags {\n  TEXT = 1,\n  CLASS = 2,\n  STYLE = 4,\n  PROPS = 8,\n  FULL_PROPS = 16,\n  HYDRATE_EVENTS = 32,\n  STABLE_FRAGMENT = 64,\n  KEYED_FRAGMENT = 128,\n  UNKEYED_FRAGMENT = 256,\n  NEED_PATCH = 512,\n  DYNAMIC_SLOTS = 1024,\n  HOISTED = -1,\n  BAIL = -2,\n}\n\nexport type VNodeChildAtom = Exclude<VNodeChild, Array<any>>\nexport type RawSlots = Exclude<\n  VNodeNormalizedChildren,\n  Array<any> | null | string\n>\n\nexport function isFragment(node: VNode): boolean\nexport function isFragment(node: unknown): node is VNode\nexport function isFragment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Fragment\n}\n\nexport function isText(node: VNode): boolean\nexport function isText(node: unknown): node is VNode\nexport function isText(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Text\n}\n\nexport function isComment(node: VNode): boolean\nexport function isComment(node: unknown): node is VNode\nexport function isComment(node: unknown): node is VNode {\n  return isVNode(node) && node.type === Comment\n}\n\nconst TEMPLATE = 'template'\nexport function isTemplate(node: VNode): boolean\nexport function isTemplate(node: unknown): node is VNode\nexport function isTemplate(node: unknown): node is VNode {\n  return isVNode(node) && node.type === TEMPLATE\n}\n\n/**\n * determine if the element is a valid element type rather than fragments and comment e.g. <template> v-if\n * @param node {VNode} node to be tested\n */\nexport function isValidElementNode(node: VNode): boolean\nexport function isValidElementNode(node: unknown): node is VNode\nexport function isValidElementNode(node: unknown): node is VNode {\n  return isVNode(node) && !isFragment(node) && !isComment(node)\n}\n\n/**\n * get a valid child node (not fragment nor comment)\n * @param node {VNode} node to be searched\n * @param depth {number} depth to be searched\n */\nfunction getChildren(\n  node: VNodeNormalizedChildren | VNodeChild,\n  depth: number\n): VNodeNormalizedChildren | VNodeChild {\n  if (isComment(node)) return\n  if (isFragment(node) || isTemplate(node)) {\n    return depth > 0 ? getFirstValidNode(node.children, depth - 1) : undefined\n  }\n  return node\n}\n\nexport const getFirstValidNode = (\n  nodes: VNodeNormalizedChildren,\n  maxDepth = 3\n) => {\n  if (isArray(nodes)) {\n    return getChildren(nodes[0], maxDepth)\n  } else {\n    return getChildren(nodes, maxDepth)\n  }\n}\n\nexport function renderIf(\n  condition: boolean,\n  ...args: Parameters<typeof createBlock>\n) {\n  return condition ? renderBlock(...args) : createCommentVNode('v-if', true)\n}\n\nexport function renderBlock(...args: Parameters<typeof createBlock>) {\n  return openBlock(), createBlock(...args)\n}\n\nexport const getNormalizedProps = (node: VNode) => {\n  if (!isVNode(node)) {\n    debugWarn(SCOPE, '[getNormalizedProps] must be a VNode')\n    return {}\n  }\n\n  const raw = node.props || {}\n  const type = (isVNode(node.type) ? node.type.props : undefined) || {}\n  const props: Record<string, any> = {}\n\n  Object.keys(type).forEach((key) => {\n    if (hasOwn(type[key], 'default')) {\n      props[key] = type[key].default\n    }\n  })\n\n  Object.keys(raw).forEach((key) => {\n    props[camelize(key)] = raw[key]\n  })\n\n  return props\n}\n\nexport const ensureOnlyChild = (children: VNodeArrayChildren | undefined) => {\n  if (!isArray(children) || children.length > 1) {\n    throw new Error('expect to receive a single Vue element child')\n  }\n  return children[0]\n}\n\nexport type FlattenVNodes = Array<VNodeChildAtom | RawSlots>\n\nexport const flattedChildren = (\n  children: FlattenVNodes | VNode | VNodeNormalizedChildren\n): FlattenVNodes => {\n  const vNodes = isArray(children) ? children : [children]\n  const result: FlattenVNodes = []\n\n  vNodes.forEach((child) => {\n    if (isArray(child)) {\n      result.push(...flattedChildren(child))\n    } else if (isVNode(child) && child.component?.subTree) {\n      result.push(child, ...flattedChildren(child.component.subTree))\n    } else if (isVNode(child) && isArray(child.children)) {\n      result.push(...flattedChildren(child.children))\n    } else if (isVNode(child) && child.shapeFlag === 2) {\n      // @ts-ignore\n      result.push(...flattedChildren(child.type()))\n    } else {\n      result.push(child)\n    }\n  })\n  return result\n}\n","import { isClient } from '../browser'\n\nexport const isInContainer = (\n  el?: Element,\n  container?: Element | Window\n): boolean => {\n  if (!isClient || !el || !container) return false\n\n  const elRect = el.getBoundingClientRect()\n\n  let containerRect: Pick<DOMRect, 'top' | 'bottom' | 'left' | 'right'>\n  if (container instanceof Element) {\n    containerRect = container.getBoundingClientRect()\n  } else {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0,\n    }\n  }\n  return (\n    elRect.top < containerRect.bottom &&\n    elRect.bottom > containerRect.top &&\n    elRect.right > containerRect.left &&\n    elRect.left < containerRect.right\n  )\n}\n\nexport const getOffsetTop = (el: HTMLElement) => {\n  let offset = 0\n  let parent = el\n\n  while (parent) {\n    offset += parent.offsetTop\n    parent = parent.offsetParent as HTMLElement\n  }\n\n  return offset\n}\n\nexport const getOffsetTopDistance = (\n  el: HTMLElement,\n  containerEl: HTMLElement\n) => {\n  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl))\n}\n\nexport const getClientXY = (event: MouseEvent | TouchEvent) => {\n  let clientX: number\n  let clientY: number\n  if (event.type === 'touchend') {\n    clientY = (event as TouchEvent).changedTouches[0].clientY\n    clientX = (event as TouchEvent).changedTouches[0].clientX\n  } else if (event.type.startsWith('touch')) {\n    clientY = (event as TouchEvent).touches[0].clientY\n    clientX = (event as TouchEvent).touches[0].clientX\n  } else {\n    clientY = (event as MouseEvent).clientY\n    clientX = (event as MouseEvent).clientX\n  }\n  return {\n    clientX,\n    clientY,\n  }\n}\n","import { isClient } from '../browser'\nimport { easeInOutCubic } from '../easings'\nimport { isFunction, isWindow } from '../types'\nimport { cAF, rAF } from '../raf'\nimport { getStyle } from './style'\n\nexport const isScroll = (el: HTMLElement, isVertical?: boolean): boolean => {\n  if (!isClient) return false\n\n  const key = (\n    {\n      undefined: 'overflow',\n      true: 'overflow-y',\n      false: 'overflow-x',\n    } as const\n  )[String(isVertical)]!\n  const overflow = getStyle(el, key)\n  return ['scroll', 'auto', 'overlay'].some((s) => overflow.includes(s))\n}\n\nexport const getScrollContainer = (\n  el: HTMLElement,\n  isVertical?: boolean\n): Window | HTMLElement | undefined => {\n  if (!isClient) return\n\n  let parent: HTMLElement = el\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent))\n      return window\n\n    if (isScroll(parent, isVertical)) return parent\n\n    parent = parent.parentNode as HTMLElement\n  }\n\n  return parent\n}\n\nlet scrollBarWidth: number\nexport const getScrollBarWidth = (namespace: string): number => {\n  if (!isClient) return 0\n  if (scrollBarWidth !== undefined) return scrollBarWidth\n\n  const outer = document.createElement('div')\n  outer.className = `${namespace}-scrollbar__wrap`\n  outer.style.visibility = 'hidden'\n  outer.style.width = '100px'\n  outer.style.position = 'absolute'\n  outer.style.top = '-9999px'\n  document.body.appendChild(outer)\n\n  const widthNoScroll = outer.offsetWidth\n  outer.style.overflow = 'scroll'\n\n  const inner = document.createElement('div')\n  inner.style.width = '100%'\n  outer.appendChild(inner)\n\n  const widthWithScroll = inner.offsetWidth\n  outer.parentNode?.removeChild(outer)\n  scrollBarWidth = widthNoScroll - widthWithScroll\n\n  return scrollBarWidth\n}\n\n/**\n * Scroll with in the container element, positioning the **selected** element at the top\n * of the container\n */\nexport function scrollIntoView(\n  container: HTMLElement,\n  selected: HTMLElement\n): void {\n  if (!isClient) return\n\n  if (!selected) {\n    container.scrollTop = 0\n    return\n  }\n\n  const offsetParents: HTMLElement[] = []\n  let pointer = selected.offsetParent\n  while (\n    pointer !== null &&\n    container !== pointer &&\n    container.contains(pointer)\n  ) {\n    offsetParents.push(pointer as HTMLElement)\n    pointer = (pointer as HTMLElement).offsetParent\n  }\n  const top =\n    selected.offsetTop +\n    offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0)\n  const bottom = top + selected.offsetHeight\n  const viewRectTop = container.scrollTop\n  const viewRectBottom = viewRectTop + container.clientHeight\n\n  if (top < viewRectTop) {\n    container.scrollTop = top\n  } else if (bottom > viewRectBottom) {\n    container.scrollTop = bottom - container.clientHeight\n  }\n}\n\nexport function animateScrollTo(\n  container: HTMLElement | Window,\n  from: number,\n  to: number,\n  duration: number,\n  callback?: unknown\n) {\n  const startTime = Date.now()\n\n  let handle: number | undefined\n  const scroll = () => {\n    const timestamp = Date.now()\n    const time = timestamp - startTime\n    const nextScrollTop = easeInOutCubic(\n      time > duration ? duration : time,\n      from,\n      to,\n      duration\n    )\n\n    if (isWindow(container)) {\n      container.scrollTo(window.pageXOffset, nextScrollTop)\n    } else {\n      container.scrollTop = nextScrollTop\n    }\n    if (time < duration) {\n      handle = rAF(scroll)\n    } else if (isFunction(callback)) {\n      callback()\n    }\n  }\n\n  scroll()\n\n  return () => {\n    handle && cAF(handle)\n  }\n}\n\nexport const getScrollElement = (\n  target: HTMLElement,\n  container: HTMLElement | Window\n) => {\n  if (isWindow(container)) {\n    return target.ownerDocument.documentElement\n  }\n  return container\n}\n\nexport const getScrollTop = (container: HTMLElement | Window) => {\n  if (isWindow(container)) {\n    return window.scrollY\n  }\n  return container.scrollTop\n}\n","import { camelize, hyphenate, capitalize as toCapitalize } from '@vue/shared'\n\nexport { camelize, hyphenate }\nexport const kebabCase = hyphenate\n\n/**\n * fork from {@link https://github.com/sindresorhus/escape-string-regexp}\n */\nexport const escapeStringRegexp = (string = '') =>\n  string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d')\n\n// NOTE: improve capitalize types. Restore previous code after the [PR](https://github.com/vuejs/core/pull/6212) merge\nexport const capitalize = <T extends string>(str: T) =>\n  toCapitalize(str) as Capitalize<T>\n","export const isKorean = (text: string) =>\n  /([\\uAC00-\\uD7AF\\u3130-\\u318F])+/gi.test(text)\n","import { isArray } from './types'\n\nexport const unique = <T>(arr: T[]) => [...new Set(arr)]\n\ntype Many<T> = T | ReadonlyArray<T>\n// TODO: rename to `ensureArray`\n/** like `_.castArray`, except falsy value returns empty array. */\nexport const castArray = <T>(arr: Many<T>): T[] => {\n  if (!arr && (arr as any) !== 0) return []\n  return isArray(arr) ? arr : [arr as T]\n}\n\n// TODO: remove import alias\n// avoid naming conflicts\nexport { castArray as ensureArray } from 'lodash-unified'\n","import { isArray, isObject, isString } from '@vue/shared'\nimport { isNil } from 'lodash-unified'\n\nexport {\n  isArray,\n  isFunction,\n  isObject,\n  isString,\n  isDate,\n  isPromise,\n  isSymbol,\n  isPlainObject,\n} from '@vue/shared'\n\nexport const isUndefined = (val: any): val is undefined => val === undefined\nexport const isBoolean = (val: any): val is boolean => typeof val === 'boolean'\nexport const isNumber = (val: any): val is number => typeof val === 'number'\n\nexport const isEmpty = (val: unknown) =>\n  (!val && val !== 0) ||\n  (isArray(val) && val.length === 0) ||\n  (isObject(val) && !Object.keys(val).length)\n\nexport const isElement = (e: unknown): e is Element => {\n  if (typeof Element === 'undefined') return false\n  return e instanceof Element\n}\n\nexport const isPropAbsent = (prop: unknown): prop is null | undefined =>\n  isNil(prop)\n\nexport const isStringNumber = (val: string): boolean => {\n  if (!isString(val)) {\n    return false\n  }\n  return !Number.isNaN(Number(val))\n}\n\nexport const isWindow = (val: unknown): val is Window => val === window\n"],"names":["isHTMLElement","e","Element","isFocusable","element","tabIndex","getAttribute","hasAttribute","nodeName","href","rel","type","focusElement","el","options","focus","cleanup","setAttribute","removeAttribute","ElementPlusError","Error","constructor","m","name","throwError","scope","debugWarn","message","composeRefs","refs","forEach","ref","isFunction","value","epPropKey","definePropType","val","isEpProp","isObject","buildProp","prop","key","values","required","default","defaultValue","validator","_validator","valid","allowedValues","Array","from","hasOwn","push","includes","length","allowValuesText","Set","map","JSON","stringify","join","warn","epProp","buildProps","props","fromPairs","Object","entries","option","composeEventHandlers","theirsHandler","oursHandler","checkForDefaultPrevented","handleEvent","event","shouldPrevent","iconPropType","String","Function","CloseComponents","Close","TypeComponents","SuccessFilled","InfoFilled","WarningFilled","CircleCloseFilled","TypeComponentsMap","primary","success","warning","error","info","ValidateComponentsMap","validating","Loading","CircleCheck","CircleClose","classNameToArray","cls","split","filter","item","trim","hasClass","classList","contains","addClass","add","removeClass","remove","getStyle","styleName","_a","isClient","camelize","style","computed","document","defaultView","getComputedStyle","addUnit","defaultUnit","isNumber","isStringNumber","isString","rAF","fn","window","requestAnimationFrame","setTimeout","withInstall","main","extra","install","app","comp","component","withInstallFunction","_context","config","globalProperties","withNoopInstall","NOOP","keysOf","arr","keys","getProp","obj","path","get","set","isFirefox","test","navigator","userAgent","mutable","isValidComponentSize","componentSizes","PatchFlags","PatchFlags2","flattedChildren","children","vNodes","isArray","result","child","isVNode","subTree","shapeFlag","getClientXY","clientX","clientY","changedTouches","startsWith","touches","scrollBarWidth","getScrollBarWidth","namespace","outer","createElement","className","visibility","width","position","top","body","appendChild","widthNoScroll","offsetWidth","overflow","inner","widthWithScroll","parentNode","removeChild","scrollIntoView","container","selected","scrollTop","offsetParents","pointer","offsetParent","offsetTop","reduce","prev","curr","bottom","offsetHeight","viewRectTop","viewRectBottom","clientHeight","escapeStringRegexp","string","replace","capitalize","str","capitalize$1","isKorean","text","castArray","isUndefined","isBoolean","isElement","isPropAbsent","isNil","Number","isNaN"],"sourceRoot":""}